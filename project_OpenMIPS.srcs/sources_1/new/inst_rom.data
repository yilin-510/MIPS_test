// --- 第一阶段：寄存器初始化与逻辑运算 ---
3401000A    // [00] ori  $1, $0, 10      ; $1 = 10 (0xA)
34020003    // [04] ori  $2, $0, 3       ; $2 = 3
3C030000    // [08] lui  $3, 0x0000      ; $3 = 0x00000000
34632000    // [0C] ori  $3, $3, 0x2000  ; $3 = 0x2000 (基地址)
00222024    // [10] and  $4, $1, $2      ; $4 = 10 & 3 = 2
00222825    // [14] or   $5, $1, $2      ; $5 = 10 | 3 = 11
00223026    // [18] xor  $6, $1, $2      ; $6 = 10 ^ 3 = 9
00223827    // [1C] nor  $7, $1, $2      ; $7 = ~(10 | 3) = 0xFFFFFFF4

// --- 第二阶段：移位运算 ---
00024080    // [20] sll  $8, $2, 2       ; $8 = 3 << 2 = 12
00084882    // [24] srl  $9, $8, 1       ; $9 = 12 >> 1 = 6
00415004    // [28] sllv $10, $1, $2     ; $10 = 10 << 3 = 80

// --- 第三阶段：算术运算 ---
00225820    // [2C] add  $11, $1, $2     ; $11 = 10 + 3 = 13
00226022    // [30] sub  $12, $1, $2     ; $12 = 10 - 3 = 7
0041682A    // [34] slt  $13, $2, $1     ; $13 = (3 < 10) = 1
218E0005    // [38] addi $14, $12, 5     ; $14 = 7 + 5 = 12

// --- 第四阶段：HILO 寄存器与乘除法 ---
00220018    // [3C] mult $1, $2          ; HI/LO = 10 * 3 = 30
00007812    // [40] mflo $15             ; $15 = 30
00008010    // [44] mfhi $16             ; $16 = 0
0022001A    // [48] div  $1, $2          ; LO=3, HI=1 (10/3=3...1)
00008812    // [49] mflo $17             ; $17 = 3

// --- 第五阶段：存储与加载 (Load/Store) ---
AC6B0000    // [50] sw   $11, 0($3)      ; mem[0x2000] = 13
AC6C0004    // [54] sw   $12, 4($3)      ; mem[0x2004] = 7
8C720000    // [58] lw   $18, 0($3)      ; $18 = 13
8C730004    // [5C] lw   $19, 4($3)      ; $19 = 7

// --- 第六阶段：跳转与分支控制 ---
12530002    // [60] beq  $18, $19, +2    ; 13 == 7 ? 假，不跳转
00000000    // [64] nop                  ; 延迟槽
3414AAAA    // [68] ori  $20, $0, 0xAAAA ; 执行到此处说明 beq 没跳
16530002    // [6C] bne  $18, $19, +2    ; 13 != 7 ? 真，跳转至 [7C]
00000000    // [70] nop                  ; 延迟槽
3415BBBB    // [74] ori  $21, $0, 0xBBBB ; 该指令被跳过

08000021    // [78] j    0x84            ; 跳转到 [84]
00000000    // [7C] nop                  ; 延迟槽 (由于 bne 跳转，PC来到这里)
3416CCCC    // [80] ori  $22, $0, 0xCCCC ; 只有 J 指令没执行前才会运行

// --- 第七阶段：系统与特权 (CP0) ---
40816000    // [84] mtc0 $1, $12         ; 将 10 写入 CP0_Status ($12)
40016000    // [88] mfc0 $1, $12         ; 从 CP0 读回数据到 $1
0000000C    // [8C] syscall              ; 触发异常

// --- 结束循环 ---
08000024    // [90] j    0x90            ; 死循环
00000000    // [94] nop